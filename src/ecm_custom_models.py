"""Part of DECiM. This module allows for equivalent circuits (and other models) that cannot be constructed using the circuit typing and drawing interfaces to be implemented. Doing so requires modifying this module. The base version of this module was last modified on 14 March 2024 by Henrik Rodenburg.

Global variables:
override_impedance_method -- Boolean, indicates if the standard impedance calculation should be performed or not (False if standard, True if not)
custom_model -- the impedance function overriding the standard one
custom_model_diagrams -- dictionary with model names (strings) ask keys and tuples of (diagram string, impedance function) as values

Functions:
bisquert_2000_f -- custom impedance function example
spherical_diffusion_impedance -- custom impedance example
miec_transmission_line -- general equivalent circuit for mixed conductors

When adding a new function, place it below the CUSTOM MODEL FUNCTIONS header, but above the CUSTOM MODEL DICTIONARY header.

A custom impedance function can take only two arguments: the first argument must be a list of floating point values (the fit parameters) and the second argument must be a NumPy array of frequencies. It must return a NumPy array of complex numbers whose length is equal to that of the input array of frequencies. For more details, see the bisquert_2000_f docstring.

To access a custom impedance function from DECiM, the function must be added to the custom_model_diagrams dictionary. The key is a string; its text will appear in the circuit menu in the menu bar. The value is a tuple of a circuit diagram string and the name of the function. The number of parameters generated by the circuit string must match the number of parameters used in the custom impedance function."""

###########
##IMPORTS##
###########

import numpy as np

############
##SETTINGS##
############

override_impedance_method = False #This variable indicates whether or not the standard impedance method of the Circuit class in ecm_circuits should be overridden. Should be False upon program start-up.
custom_model_name = None #The function that replaces the standard impedance method if override_impedance_method is set to True. Should be None upon program start-up.

##########################
##CUSTOM MODEL FUNCTIONS##
##########################

def bisquert_2000_f(fp, freq):
    """Example impedance function no. 1. This is a transmission line model for porous electrodes. See Bisquert et al., J. Phys. Chem. B., 2000, 104, 2287-2298.
    
    Arguments:
    fp -- list of fit parameters
    freq -- Real NumPy array of linear frequencies f
    
    Returns:
    Complex NumPy array of impedances Z
    
    In the custom_model_diagrams dictionary, the diagram for this function is R0R1Q0. This diagram has two one-parameter elements and one two-parameter element. The circuit string is read from left to right, so: fp[0] is R0, fp[1] is R1, fp[2] is Q0, and fp[3] is n0, which is the exponent belonging to the CPE Q0."""
    omega_3 = 1/((fp[1]*fp[2])**(1/fp[3]))
    omega_L = 1/((fp[0]*fp[2])**(1/fp[3]))
    print(omega_3/omega_L)
    return ((fp[0]*fp[1])/(1+((1j*2*np.pi*freq/omega_3)**fp[3])))**0.5 * (1/np.tanh((omega_3/omega_L)**(fp[3]/2)*(1+(1j*2*np.pi*freq/omega_3)**fp[3])**0.5)) #freq is linear (f); it must be made angular (omega) by multiplying with 2*np.pi

def spherical_diffusion_impedance(fp, freq):
    """Example impedance function no. 2. This is a simple spherical diffusion model. See Moskon & Gaberscek, J. Power Sources Adv. 2021, 7, 100047.
    
    Arguments:
    fp -- list of fit parameters
    freq -- Real NumPy array of linear frequencies f
    
    Returns:
    Complex NumPy array of impedances Z
    
    In the custom_model_diagrams dictionary, the diagram for this function is R0C0. This diagram has two one-parameter elements. The circuit string is read from left to right, so fp[0] is R0 and fp[1] is C0."""
    sqtm = np.sqrt(1j*2*np.pi*freq*fp[0]*fp[1])
    return fp[0]*np.tanh(sqtm)/(sqtm - np.tanh(sqtm))

def miec_transmission_line(fp, freq):
    """Transmission line model for mixed conductors based on Jamnik & Maier, J. Electrochem. Soc. 1999, 146(11), 4183-4188.
    Also featured in Lee et al., Monatsh. Chem. 2009, 140, 1113-1119.
    
    Arguments:
    fp -- list of fit parameters
    freq -- Real NumPy array of linear frequencies f
    
    Returns:
    Complex NumPy array of impedances Z
    
    Model parameters:
    R0, fp[0] -- R_ion
    R1, fp[1] -- R_eon
    R2, fp[2] -- R_ion^perp
    R3, fp[3] -- R_eon^perp
    C0, fp[4] -- C_inf
    Q0, fp[5] -- C_chem
    n0, fp[6] -- Sample thickness (in meters)
    C1, fp[7] -- C_ion^perp
    C2, fp[8] -- C_eon^perp
    L0, fp[9] -- Lead wire inductance"""
    omega = 2*np.pi*freq
    z_ion_perp = fp[2]/(1 + 1j*omega*fp[2]*fp[7])
    z_eon_perp = fp[3]/(1 + 1j*omega*fp[3]*fp[8])
    d_chem = fp[6]**2/((fp[0] + fp[1])*fp[5])
    z_inf = fp[0]*fp[1]/(fp[0] + fp[1]) + 2*(z_ion_perp*z_eon_perp)/(z_ion_perp + z_eon_perp)
    z_0 = 1/(1/(fp[0] + 2*z_ion_perp) + 1/(fp[1] + 2*z_eon_perp))
    root = np.sqrt(1j*omega*(fp[6]**2)/(4*d_chem))
    troot = np.tanh(root)
    com = (fp[0] + fp[1])/(2*(z_ion_perp + z_eon_perp))
    numer = (1 + com)*troot
    denom = root + com*troot
    z_non_periph = z_inf + (z_0 - z_inf)*(numer/denom)
    z_c_inf = 1/(1j*omega*fp[4])
    z_cap = 1/(1/z_non_periph + 1/z_c_inf)
    z_l_wire = 1j*omega*fp[9]
    return z_cap + z_l_wire

#Other functions go here...

###########################
##CUSTOM MODEL DICTIONARY##
###########################

#Functions must be added to this dictionary
custom_model_diagrams = {"Porous electrode transmission line": ("R0R1Q0", bisquert_2000_f), "Spherical diffusion": ("R0C0", spherical_diffusion_impedance), "Mixed conductor": ("R0R1R2R3C0Q0C1C2L0", miec_transmission_line)}
